\section{\sysname\space | Overview}\label{sec:overview}

In \Cref{subsec:search}, we focus on the timing aspects we consider for the two protocols that operate in parallel in the considered decentralized marketplace search mechanism, as illustrated in \Cref{fig:system_arch}: 
the market indexing mechanism (right), as well as our proposed provider-selection and search mechanisms (left).\etienne[\done]{The indexing and search were already discussed in the previous sections, so it may be surprising to read that these are yet more mechanisms. Maybe say you detail them?}
We then describe the key principles of the main module involved in \sysname's search mechanism in \Cref{subsec:cool}: the \emph{Provider Selection Module} (PSM).

%\subsection{Market indexing mechanism}\label{subsec:market}
%\etienne{consider pruning redundancies with earlier similar descriptions (section 3.1)}
%The right half of \Cref{fig:system_arch} illustrates the process through which providers update their view on the market's state, in two alternating steps.
%(Step a) All providers receive a message $\mathbf{<NEW>}$ that a new asset appeared on the market. 
%Providers obtain market events $\mathbf{<NEW>}$ in periodic batches, that are verifiably complete and tamper-proof.
%(b) In reaction, based on these $\mathbf{<NEW>}$ messages, each provider $j$ updates its local market index.

\subsection{Protocol delays and timing}\label{subsec:search}

\etienne[\done]{This is quite redundant with content in section 3. It is also more background material than a contribution of the paper. It could be turned into a timing analysis without repeating the protocol already described previously.}
We focus here on the timing of our protocol steps.
\Cref{fig:system_arch} shows the behaviour of a consumer $i$ that uses the search mechanism and providers 1 to $N_{P}$ who provide this service: 
(step 1) at $t_{gen}$, the consumer $i$, on the left of \Cref{fig:system_arch}, first generates a request message $\mathbf{<RQ>}$ .
(2) The request is directed by the PSM to some provider $j$ at $t_{send}$, after a computation delay $\delta_{PSM}$. 
(3) The request is sent through the network to the chosen provider $j$, with a delay $\delta_{i,j}$. 
The untrusted host then receives the request message and forwards it to the TEE, who enqueues it.
(4) The request waits for $\delta_{queue}$ in the TEE's queue until service of this request begins at $t_{serv}$.
The time to serve the request after $t_{serv}$ is $\delta_{serv}=D$.
(5) After service completion, the TEE sends the response message $\mathbf{<RSP>}$ out to the untrusted host, who, if it is malicious, may delay the response by $\delta_{att}$. 
The response is then sent through the network to the consumer $i$, with a return-trip delay $\delta_{i,j}$.
(6) At $t_{recv}$, the consumer $i$ finally receives the response message $\mathbf{<RSP>}$ and the PSM logs the experienced round-trip latency, for future interactions. 
Let $k$ be the number of request-response interactions between consumer $i$ and provider $j$. 
Consumer $i$ logs $\Delta^{k}_{i,j}=t_{recv}-t_{send}=\delta_{queue}+D+2\delta_{i,j}+\delta_{att}$.

Concurrently, on the right of \Cref{fig:system_arch}, as a new asset $A$ appears on the market, $\mathbf{<NEW>}$ messages are broadcast to all providers (step a). 
Then, in step b, we consider that $A$ is added to the index at the same $t_{index}$ for all providers.
For $A$ to appear in a given $\mathbf{<RSP>}$ message, whose request would match $A$, $A$ must be indexed before serving the request: we require $t_{index}<t_{serv}$.
Furthermore, due to the TEE's computation integrity, an indexed asset $A$ will appear in responses if it matches the request.
Therefore, from a consumer's point of view, a response's freshness with respect to the market's state is the latency once service starts: $\delta_{fresh}=D+\delta_{i,j}+\delta_{att}$.
Honest consumers can maximize the freshness (i.e., minimize $\delta_{fresh}$) by choosing close providers in the network (low $\delta_{i,j}$), with high computation power (low $D$), and who are honest ($\delta_{att}=0$).
%\sysname does so for each consumer $i$ individually, by selecting providers so as to minimize the average of $\Delta^{k}_{i,j}$ round-trip latencies, which contain $\delta_{i,j}$ and $\delta_{att}$, experienced across all providers $j\in\llbracket 1,N_{P}\rrbracket$.

\begin{figure}
    \centering
    \includegraphics[trim={2mm 0 0 0},scale=0.95]{\figpatharch}
    \caption{High-level system architecture}\vspace{-0.5cm}
    \label{fig:system_arch}
%    \Description[]{}
\end{figure}

\subsection{COoL | Client-side Optimization of Latencies}\label{subsec:cool}

The key mechanism in \sysname is the Provider Selection Module (PSM). 
Before providing a detailed description, we first introduce the PSM's key principles.
A consumer wants the freshest information about the market, that is, responses that contain the newest relevant assets.
%The content of responses is immutable once they are generated thanks to TEEs, so freshness is achieved by minimizing the time between response generation at the provider and response reception at the consumer (i.e., the latency of step 5 in \Cref{fig:system_arch}). \etienne{It might not be clear that once the market event has been received by the provider, it has been processed and the information is in the index and the TEE ensures it cannot be ignored.}
As a secondary goal, consumers also want to minimize their request-response latencies, for user experience purposes.

As a consequence, the goal of a consumer's PSM is to prefer sending requests to providers with whom the consumer experiences low round-trip latencies, and in particular to avoid malicious providers leading timing attacks ($\delta_{att}>0$). 
Each consumer $i$'s PSM does so individually, by performing a provider selection based on \emph{Client-side Optimization of Latencies} (COoL): 
it aggregates each past request $k$'s round-trip latency $\Delta^{k}_{i,j}$ with each provider $j$, then tunes the probability to select each provider for future requests, so as to decrease the average round-trip request latency across all providers over time.
Considering a target throughput $\lambda_{r}$ of requests to send, consumer $i$ divides this throughput such that each provider $j$ receives a share $\lambda_{i,j}=r_{i,j}\lambda_{r}$ of the requests (with $\sum_{j\in \llbracket 1,N_{P}\rrbracket}r_{i,j}=1$).
At step 2 of the search mechanism (see \Cref{fig:system_arch}), the goal of the \emph{Provider Selection Module} is to tune all $r_{i,j}$ such that the average round-trip latency is minimized.
Doing so, \sysname's PSM indeed chooses providers with low round-trip latencies. 
Moreover, if an honest and a malicious provider $j$ and $j'$ have the same service time $D$ and network latencies $\delta_{i,j}=\delta_{i,j'}$ to consumer $i$, then consumer $i$ will preferentially choose the honest provider, whose $\delta_{att}=0$.
%\etienne{This overview details the solution, but not why it addresses the problem. I think this is what reviewers will be looking for.}

\section{Model \& problem statement}\label{sec:problem_statement}

We detail the model of decentralized marketplace search that we consider and formalize our system and attacker models.

\etienne[\done]{I would merge this section 2 with the following section 3, since the actual formalization of the attack is in section 3 and not in section 2. The content of section 2 can be summarized in the header as a brief overview (top-down) of the content of the new, merged section.}

% In this section, we first provide the model of decentralized marketplace search that we consider in this paper.
% We then further formalize our system and attacker models.

\subsection{Roles \& interactions}

\begin{figure}
    \centering
    \includegraphics[scale=0.8]{\figpathmodel}
    \caption{\emph{Marketplace search model} | Consumers send requests to Providers of the search mechanism about the market's state; Providers then respond with a list of assets they previously learned from the Market over time.}\vspace{-0.5cm}
    \label{fig:system_model}
\end{figure}

We assume the system is composed of the following three entities, also illustrated in Figure~\ref{fig:system_model}: 
(i)~the \emph{market} (represented in the right part of the figure) is the blockchain- and/or decentralized storage-based system in which assets are registered for future transactions, for example, to be sold or rented. 
\emph{contributors} of assets create the offer side of the market. 
In the scope of this paper, contributors and their actions are abstracted as a stream of \emph{market events} towards \emph{providers}; 
(ii)~\emph{consumers} (depicted in the left part of the figure) are users of the search mechanism;
and (iii)~\emph{providers} (depicted in the middle of the figure) provide their computing power to run the search mechanism: 
they act as intermediaries between the market and consumers.
To do so, providers update a local index of the market state according to the market events they receive, which they use to respond to consumers' search requests.

Some providers may collude with some consumers and offer these better treatments, typically in the exchange of bribes.
These actors are considered malicious.
The objective of malicious consumers is to maximize the probability that they are the first to see new assets before the rest of the consumer base.
We call Never-Before-Seen assets (NBSa) assets that are not yet discovered by any consumer.
NBSa become discovered NBSa (dNBSa) by some consumer once a response that contains those NBSa arrives at that consumer.
We refer to attacks that impact a consumer's share of dNBSa compared to others' as \emph{information front-running} (IFR) attacks.

\subsection{System formalization \& constraints}

As illustrated by \Cref{fig:system_model}, we consider $N_{C}$ consumers and $N_{P}$ providers placed on a network topology.
The communication delay between a consumer $i$ and a provider $j$ is $\delta_{i,j}$ (also referred to as $\delta_{net}$ as a generic notation).
Consumers may be co-located with providers, in which case we assume that communication is negligible compared to queuing and computation delays, i.e., $\delta_{i,j}=0s$.

We assume that two protocols run in parallel: the market and the search mechanism. 
Messages sent as part of those protocols will be represented in the format $\mathbf{<type:data>}$ (or the short-hand $\mathbf{<type>}$). 
On the market side, we assume that new assets emanate from the market towards providers, at an average rate $\lambda_{a}$.
For each new asset, $\mathbf{<NEW>}$ messages are broadcast to all providers. We assume (for the sake of simplicity) that all providers receive $\mathbf{<NEW>}$ messages at the same time.\etienne[\done]{revise to avoid passive tense.}
The representation of assets in $\mathbf{<NEW>}$ messages contains all the metadata necessary for subsequent indexing (e.g., its defining keywords). 

Concurrently, as part of the search mechanism, consumers send requests $\mathbf{<RQ>}$ to providers.
Requests contain a list of keywords of interest to the consumer.
Each consumer sends requests at a rate $\lambda_{r}$, each request to a single provider.
The provider handles those $\mathbf{<RQ>}$ messages following a First-In-First-Out policy. 
Specifically, messages wait in the queue for a delay $\delta_{q}$, depending on the queue size at arrival. 
When a request $\mathbf{<RQ>}$ is handled, the provider searches their local index of assets according to the request's keywords.
A fixed response time $D$ is required to handle the request. 
Then, they respond with a message $\mathbf{<RSP>}$, containing a list of assets that matched the filters. 
Note that only assets whose $\mathbf{<NEW>}$ message arrived before the consumer's request can be present in $\mathbf{<RSP>}$ messages.

\subsection{Building blocks}

We now describe the protocols and building blocks forming the foundation of this work. 

\subsubsection{Trusted Execution Environments}

Our work and the DeSearch protocol described below leverage Trusted Execution Environments (TEEs), namely Intel SGX~\cite{costan2016intel}, to guarantee the integrity and confidentiality of the search protocol's computations and communication.

TEEs are hardware-based security components integrated in CPUs.
They enable running code in a protected environment, called an enclave.
An enclave is isolated from the rest of the system including the operating system and other applications. 
This enclave can be remotely attested, e.g., by a consumer, to prove that the code running inside it is the expected one and is indeed running in a genuine TEE environment. 
Following this attestation, a secure channel can be established between the consumer and the enclave, to ensure confidentiality and integrity of their communications.
In our context, this means that the host, which may be malicious and is, therefore, not trusted, is not able to modify the content of the responses sent by the enclave.
However, the host is still able to delay the responses, once they are outside the TEE, a property that we exploit in this paper. 

\subsubsection{DeSearch~\cite{liBringingDecentralizedSearch2021}}

DeSearch is a decentralized search protocol for decentralized marketplaces, that leverages TEEs to protect consumers from censorship and bias attacks.
It is an epoch-based protocol that follows a 3-step pipeline: new assets registered on some verifiable storage, like blockchains or IPFS~\cite{doan2022towards}, are first crawled; these crawled assets are then indexed in the following epoch; and finally, ``Queriers'', our providers, serve search requests from clients, our consumers, in the third epoch. Our work focuses on the last step of this pipeline: the index created at the end of DeSearch's second step includes the new assets from the market.
This index is then fetched and served by providers.
That is, in this paper, we abstract DeSearch's phases upstream of the search mechanism as the market (right side of \Cref{fig:system_model}).

DeSearch uses TEEs to guarantee that results are complete and tamper-proof, such that providers cannot censor or bias results.
Additionally, it is necessary to hide accesses to the index of assets in memory from the possibly malicious host, as observing memory access patterns may allow it to infer the content of requests and perform targeted censorship.
In DeSearch and our work this threat is prevented by the use of Oblivious RAM, specifically Circuit-ORAM~\cite{wangCircuitORAMTightness2015} for accessing the index of assets.
Note that while ORAM randomizes memory access patterns, it also prevents the parallelization of serving requests across multiple threads accessing the same shared index~\cite{wangCircuitORAMTightness2015}.
As a result, both for DeSearch and \sysname it is assumed that requests are served sequentially.

\subsection{Threat model}

We assume that a fraction $c_{M}$ of consumers and $p_{M}$ of providers are malicious in the system. 
In the following, for the purpose of intuitive exposition, we consider that half the consumer-base is malicious ($c_{M}=50\%$) unless otherwise specified.
Specific attack behaviors are discussed in later subsections.
All other actors are assumed to be honest and they therefore follow the protocol correctly.

We assume that Providers use TEEs to protect the integrity of the search protocol as well as the confidentiality of the request/response messages. 
%In that case, the content of messages is considered tamper-proof, and the confidentiality of request and response messages in transit is ensured. 
%We consider for comparison purposes a baseline that does not use TEEs and therefore does not guarantee integrity and confidentiality.

We assume that malicious actors have similar available computing power compared to honest actors with the same role (e.g., between consumers).
In total, this computing power is proportional to $c_{M}$ and $p_{M}$. 
We assume that honest and malicious consumers have a respective request budget proportional to their fraction of the total population, e.g., proportional to $c_{M}$ for malicious consumers. 

\subsubsection{Adversarial objective}

We assume that malicious providers gain more when malicious consumers can acquire assets instead of honest ones (e.g., through bribes). 
The common objective for malicious actors is to maximize their share of discovered Never-Before-Seen assets (NBS-assets) compared to honest consumers.
We define that an asset $A$ was discovered first by a given consumer if a response $\mathbf{<RSP>}$ containing that asset was received by that consumer before any other consumer. 
The strength of the \emph{information front-running} experienced by the malicious faction in a given time frame is measured by the fraction of NBS-assets discovered first by malicious consumers, compared to the total number of new assets. 
The higher above $c_{M}$ this fraction is, the bigger the advantage malicious customers have over honest ones in future market transactions.

Given that both honest and malicious consumers compete over the same set of assets, preventing honest consumers from discovering NBS-assets first is a viable strategy for the malicious faction. 
The means available to the malicious faction are discussed in the following subsections and illustrated by \Cref{fig:attack_model}.

\subsection{Attacks formalization}

Based on the system constraints and the malicious faction's objective, we now define attacks led by malicious actors.

\begin{figure}
    \centering
    \begin{subfigure}{\linewidth}
        \centering
    \includegraphics[scale=0.8,page=1]{\figpathattack}
        \subcaption{Fault-free | 
        Consumer and Provider exchange a request for a response containing a list of assets.}
        \label{fig:fault_free}
    \end{subfigure}
    \begin{subfigure}{\linewidth}
        \centering
        \includegraphics[scale=0.8,page=2]{\figpathattack}
        \subcaption{Content attack | 
        Without TEEs, a malicious provider can send back fake or old assets to hinder asset discovery by honest consumers.}
        \label{fig:content_attack}
    \end{subfigure}
    \begin{subfigure}{\linewidth}
        \centering
        \includegraphics[scale=0.8,page=3]{\figpathattack}
        \subcaption{Timing attack |
        Content attacks (\Cref{sub@fig:content_attack}) are not feasible with TEEs, but providers can still delay responses so honest consumers receive staler market information than malicious ones.}
        \label{fig:timing_attack}
    \end{subfigure}
    \caption{Provider-side attack models on decentralized marketplace search}\vspace{-0.5cm}
    \label{fig:attack_model}
\end{figure}

\subsubsection{Content attacks} 

To compare the IFR attack impact in systems with and without TEEs, a strawman approach without TEEs is considered where malicious actors can have the most impact on the system. 
Indeed, without TEEs, malicious providers are able to read requests plainly and to modify (e.g., to fake) the content of the corresponding responses (\Cref{sub@fig:content_attack}), instead of sending only real assets as in the fault-free case (\Cref{sub@fig:fault_free}). 
Consequently, in the worst case, if an honest request is served by a malicious provider, it cannot be used to discover new assets.
As a result, for the same number of sent requests, malicious consumers have more opportunities to discover new assets than honest consumers.
We refer to this worst-case as \emph{content attacks}.
%Note that this attack becomes impossible in search systems with TEEs and verifiable result completeness, like DeSearch~\cite{liBringingDecentralizedSearch2021}.
%We present content attacks to be able to compare the IFR attack impact in systems with and without TEEs.

\etienne[\done]{Is it important to present this attack after saying that we build upon DeSearch? I could be simpler to mention in the DeSearch subsection in much shorter form saying that DeSearch prevents content attacks with a brief def. and that they are not the concern in this work.}

\subsubsection{Timing attacks}

%Using TEEs upholds the integrity and confidentiality of the search protocol, meaning honest and malicious consumers both receive correct responses and, considering an equal number of sent requests, they have the same number of opportunities to discover new assets. 
While TEEs uphold the integrity and confidentiality of the search protocol, TEEs do not prevent malicious providers from delaying responses to honest consumers.
This is a novel attack that TEEs cannot solve by themselves, where the surrounding host may arbitrarily delay messages coming in or out of the TEE, based on the message sender or recipient.\etienne[\done]{from beginning to end of paragraph: can be simplified/shortened significantly.}
Indeed, malicious providers can delay sending responses back to honest consumers by some delay $\delta_{att}$ (\Cref{sub@fig:timing_attack}), while they respond to malicious consumers immediately after computation, like the fault-free behavior (\Cref{sub@fig:fault_free}). 
Due to the TEE's computation integrity and its secure channel with the consumer, the response is correct and tamper-proof. 
Therefore, $\delta_{att}$ should be applied after the response is computed to lower its freshness.\etienne[\done]{Clarify why as this may not be clear immediately for all readers (computation integrity).}
%Staler responses to honest consumers contributes to the information front-running advantage experienced by malicious consumers, that receive fresh responses from any provider.
We refer to this behavior as a \emph{timing attack}.
We consider that malicious providers do not drop $\mathbf{<NEW>}$ messages.
With DeSearch~\cite{liBringingDecentralizedSearch2021}, search results are verifiably complete each epoch.

\subsubsection{Cuckoo attacks}

In this attack, malicious consumers target honest providers by overwhelming them with requests in order to slow them down.
Consequently, honest consumers who choose providers with lower latencies will leave honest providers in favor of malicious providers, who give them staler information through timing attacks.
We call this consumer-side attack a \emph{cuckoo-timing} attack.
We also evaluate cuckoo attacks on top on content attacks, i.e., \emph{cuckoo-content attacks}, for comparison purposes.
